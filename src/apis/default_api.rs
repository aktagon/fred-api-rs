/*
 * FRED API
 *
 * Federal Reserve Economic Data (FRED) API - Economic data from the Federal Reserve Bank of St. Louis
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`fred_category_children_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredCategoryChildrenGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_category_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredCategoryGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_category_related_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredCategoryRelatedGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_category_related_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredCategoryRelatedTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_category_series_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredCategorySeriesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_category_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredCategoryTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_related_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredRelatedTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_release_dates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredReleaseDatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_release_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredReleaseGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_release_related_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredReleaseRelatedTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_release_series_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredReleaseSeriesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_release_sources_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredReleaseSourcesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_release_tables_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredReleaseTablesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_release_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredReleaseTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_releases_dates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredReleasesDatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_releases_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredReleasesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_series_categories_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSeriesCategoriesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_series_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSeriesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_series_observations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSeriesObservationsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_series_release_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSeriesReleaseGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_series_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSeriesSearchGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_series_search_related_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSeriesSearchRelatedTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_series_search_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSeriesSearchTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_series_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSeriesTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_series_updates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSeriesUpdatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_series_vintagedates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSeriesVintagedatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_source_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSourceGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_source_releases_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSourceReleasesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_sources_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredSourcesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fred_tags_series_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FredTagsSeriesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`geofred_regional_data_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GeofredRegionalDataGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`geofred_series_data_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GeofredSeriesDataGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`geofred_series_group_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GeofredSeriesGroupGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`geofred_shape_files_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GeofredShapeFilesGetError {
    UnknownValue(serde_json::Value),
}

/// Get the child categories for a specified parent category
pub async fn fred_category_children_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    category_id: Option<i32>,
) -> Result<(), Error<FredCategoryChildrenGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_category_id = category_id;

    let uri_str = format!("{}/fred/category/children", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_category_id {
        req_builder = req_builder.query(&[("category_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredCategoryChildrenGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get information about a specific category
pub async fn fred_category_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    category_id: Option<i32>,
) -> Result<String, Error<FredCategoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_category_id = category_id;

    let uri_str = format!("{}/fred/category", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_category_id {
        req_builder = req_builder.query(&[("category_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => Ok(content),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FredCategoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the related categories for a category
pub async fn fred_category_related_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    category_id: i32,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredCategoryRelatedGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_category_id = category_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/category/related", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("category_id", &p_category_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredCategoryRelatedGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the related FRED tags for one or more FRED tags within a category
pub async fn fred_category_related_tags_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    category_id: i32,
    tag_names: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_order: Option<&str>,
    exclude_tag_names: Option<&str>,
    tag_group_id: Option<&str>,
    search_text: Option<&str>,
    order_by: Option<&str>,
) -> Result<(), Error<FredCategoryRelatedTagsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_category_id = category_id;
    let p_tag_names = tag_names;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_order = sort_order;
    let p_exclude_tag_names = exclude_tag_names;
    let p_tag_group_id = tag_group_id;
    let p_search_text = search_text;
    let p_order_by = order_by;

    let uri_str = format!("{}/fred/category/related_tags", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("category_id", &p_category_id.to_string())]);
    req_builder = req_builder.query(&[("tag_names", &p_tag_names.to_string())]);
    if let Some(ref param_value) = p_exclude_tag_names {
        req_builder = req_builder.query(&[("exclude_tag_names", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tag_group_id {
        req_builder = req_builder.query(&[("tag_group_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search_text {
        req_builder = req_builder.query(&[("search_text", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by {
        req_builder = req_builder.query(&[("order_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredCategoryRelatedTagsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the series in a category
pub async fn fred_category_series_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    category_id: i32,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_order: Option<&str>,
    order_by: Option<&str>,
    filter_variable: Option<&str>,
    filter_value: Option<&str>,
    tag_names: Option<&str>,
    exclude_tag_names: Option<&str>,
) -> Result<(), Error<FredCategorySeriesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_category_id = category_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_order = sort_order;
    let p_order_by = order_by;
    let p_filter_variable = filter_variable;
    let p_filter_value = filter_value;
    let p_tag_names = tag_names;
    let p_exclude_tag_names = exclude_tag_names;

    let uri_str = format!("{}/fred/category/series", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("category_id", &p_category_id.to_string())]);
    if let Some(ref param_value) = p_order_by {
        req_builder = req_builder.query(&[("order_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter_variable {
        req_builder = req_builder.query(&[("filter_variable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter_value {
        req_builder = req_builder.query(&[("filter_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tag_names {
        req_builder = req_builder.query(&[("tag_names", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude_tag_names {
        req_builder = req_builder.query(&[("exclude_tag_names", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredCategorySeriesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the FRED tags for a category
pub async fn fred_category_tags_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    category_id: i32,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_order: Option<&str>,
    tag_names: Option<&str>,
    tag_group_id: Option<&str>,
    search_text: Option<&str>,
    order_by: Option<&str>,
) -> Result<(), Error<FredCategoryTagsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_category_id = category_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_order = sort_order;
    let p_tag_names = tag_names;
    let p_tag_group_id = tag_group_id;
    let p_search_text = search_text;
    let p_order_by = order_by;

    let uri_str = format!("{}/fred/category/tags", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("category_id", &p_category_id.to_string())]);
    if let Some(ref param_value) = p_tag_names {
        req_builder = req_builder.query(&[("tag_names", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tag_group_id {
        req_builder = req_builder.query(&[("tag_group_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search_text {
        req_builder = req_builder.query(&[("search_text", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by {
        req_builder = req_builder.query(&[("order_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredCategoryTagsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get related FRED tags for one or more FRED tags
pub async fn fred_related_tags_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    tag_names: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredRelatedTagsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_tag_names = tag_names;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/related_tags", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("tag_names", &p_tag_names.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredRelatedTagsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get release dates for a release of economic data
pub async fn fred_release_dates_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    release_id: i32,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    sort_order: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
    include_release_dates_with_no_data: Option<&str>,
) -> Result<(), Error<FredReleaseDatesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_release_id = release_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_sort_order = sort_order;
    let p_limit = limit;
    let p_offset = offset;
    let p_include_release_dates_with_no_data = include_release_dates_with_no_data;

    let uri_str = format!("{}/fred/release/dates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("release_id", &p_release_id.to_string())]);
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_release_dates_with_no_data {
        req_builder = req_builder.query(&[(
            "include_release_dates_with_no_data",
            &param_value.to_string(),
        )]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredReleaseDatesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a release of economic data
pub async fn fred_release_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    release_id: i32,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredReleaseGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_release_id = release_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/release", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("release_id", &p_release_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredReleaseGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the related FRED tags for one or more FRED tags within a release
pub async fn fred_release_related_tags_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    release_id: i32,
    tag_names: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_order: Option<&str>,
    exclude_tag_names: Option<&str>,
    tag_group_id: Option<&str>,
    search_text: Option<&str>,
    order_by: Option<&str>,
) -> Result<(), Error<FredReleaseRelatedTagsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_release_id = release_id;
    let p_tag_names = tag_names;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_order = sort_order;
    let p_exclude_tag_names = exclude_tag_names;
    let p_tag_group_id = tag_group_id;
    let p_search_text = search_text;
    let p_order_by = order_by;

    let uri_str = format!("{}/fred/release/related_tags", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("release_id", &p_release_id.to_string())]);
    req_builder = req_builder.query(&[("tag_names", &p_tag_names.to_string())]);
    if let Some(ref param_value) = p_exclude_tag_names {
        req_builder = req_builder.query(&[("exclude_tag_names", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tag_group_id {
        req_builder = req_builder.query(&[("tag_group_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search_text {
        req_builder = req_builder.query(&[("search_text", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by {
        req_builder = req_builder.query(&[("order_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredReleaseRelatedTagsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the series on a release of economic data
pub async fn fred_release_series_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    release_id: i32,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_order: Option<&str>,
    order_by: Option<&str>,
    filter_variable: Option<&str>,
    filter_value: Option<&str>,
    tag_names: Option<&str>,
    exclude_tag_names: Option<&str>,
) -> Result<(), Error<FredReleaseSeriesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_release_id = release_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_order = sort_order;
    let p_order_by = order_by;
    let p_filter_variable = filter_variable;
    let p_filter_value = filter_value;
    let p_tag_names = tag_names;
    let p_exclude_tag_names = exclude_tag_names;

    let uri_str = format!("{}/fred/release/series", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("release_id", &p_release_id.to_string())]);
    if let Some(ref param_value) = p_order_by {
        req_builder = req_builder.query(&[("order_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter_variable {
        req_builder = req_builder.query(&[("filter_variable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter_value {
        req_builder = req_builder.query(&[("filter_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tag_names {
        req_builder = req_builder.query(&[("tag_names", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude_tag_names {
        req_builder = req_builder.query(&[("exclude_tag_names", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredReleaseSeriesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the sources for a release of economic data
pub async fn fred_release_sources_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    release_id: i32,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredReleaseSourcesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_release_id = release_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/release/sources", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("release_id", &p_release_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredReleaseSourcesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get release table trees for a given release
pub async fn fred_release_tables_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    release_id: i32,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    element_id: Option<i32>,
    include_observation_values: Option<&str>,
    observation_date: Option<String>,
) -> Result<(), Error<FredReleaseTablesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_release_id = release_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_element_id = element_id;
    let p_include_observation_values = include_observation_values;
    let p_observation_date = observation_date;

    let uri_str = format!("{}/fred/release/tables", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("release_id", &p_release_id.to_string())]);
    if let Some(ref param_value) = p_element_id {
        req_builder = req_builder.query(&[("element_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_observation_values {
        req_builder =
            req_builder.query(&[("include_observation_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_observation_date {
        req_builder = req_builder.query(&[("observation_date", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredReleaseTablesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the FRED tags for a release
pub async fn fred_release_tags_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    release_id: i32,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_order: Option<&str>,
    tag_names: Option<&str>,
    tag_group_id: Option<&str>,
    search_text: Option<&str>,
    order_by: Option<&str>,
) -> Result<(), Error<FredReleaseTagsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_release_id = release_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_order = sort_order;
    let p_tag_names = tag_names;
    let p_tag_group_id = tag_group_id;
    let p_search_text = search_text;
    let p_order_by = order_by;

    let uri_str = format!("{}/fred/release/tags", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("release_id", &p_release_id.to_string())]);
    if let Some(ref param_value) = p_tag_names {
        req_builder = req_builder.query(&[("tag_names", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tag_group_id {
        req_builder = req_builder.query(&[("tag_group_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search_text {
        req_builder = req_builder.query(&[("search_text", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by {
        req_builder = req_builder.query(&[("order_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredReleaseTagsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get release dates for all releases of economic data
pub async fn fred_releases_dates_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_order: Option<&str>,
    order_by: Option<&str>,
    include_release_dates_with_no_data: Option<&str>,
) -> Result<(), Error<FredReleasesDatesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_order = sort_order;
    let p_order_by = order_by;
    let p_include_release_dates_with_no_data = include_release_dates_with_no_data;

    let uri_str = format!("{}/fred/releases/dates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by {
        req_builder = req_builder.query(&[("order_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_release_dates_with_no_data {
        req_builder = req_builder.query(&[(
            "include_release_dates_with_no_data",
            &param_value.to_string(),
        )]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredReleasesDatesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all releases of economic data
pub async fn fred_releases_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_order: Option<&str>,
    order_by: Option<&str>,
) -> Result<(), Error<FredReleasesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_order = sort_order;
    let p_order_by = order_by;

    let uri_str = format!("{}/fred/releases", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by {
        req_builder = req_builder.query(&[("order_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredReleasesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the categories for an economic data series
pub async fn fred_series_categories_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    series_id: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredSeriesCategoriesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_series_id = series_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/series/categories", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("series_id", &p_series_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSeriesCategoriesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get an economic data series
pub async fn fred_series_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    series_id: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredSeriesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_series_id = series_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/series", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("series_id", &p_series_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSeriesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the observations or data values for an economic data series
pub async fn fred_series_observations_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    series_id: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    sort_order: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
    observation_start: Option<String>,
    observation_end: Option<String>,
    units: Option<&str>,
    frequency: Option<&str>,
    aggregation_method: Option<&str>,
    output_type: Option<i32>,
    vintage_dates: Option<&str>,
) -> Result<(), Error<FredSeriesObservationsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_series_id = series_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_sort_order = sort_order;
    let p_limit = limit;
    let p_offset = offset;
    let p_observation_start = observation_start;
    let p_observation_end = observation_end;
    let p_units = units;
    let p_frequency = frequency;
    let p_aggregation_method = aggregation_method;
    let p_output_type = output_type;
    let p_vintage_dates = vintage_dates;

    let uri_str = format!("{}/fred/series/observations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("series_id", &p_series_id.to_string())]);
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_observation_start {
        req_builder = req_builder.query(&[("observation_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_observation_end {
        req_builder = req_builder.query(&[("observation_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_units {
        req_builder = req_builder.query(&[("units", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_frequency {
        req_builder = req_builder.query(&[("frequency", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_aggregation_method {
        req_builder = req_builder.query(&[("aggregation_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_type {
        req_builder = req_builder.query(&[("output_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_vintage_dates {
        req_builder = req_builder.query(&[("vintage_dates", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSeriesObservationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the release for an economic data series
pub async fn fred_series_release_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    series_id: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredSeriesReleaseGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_series_id = series_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/series/release", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("series_id", &p_series_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSeriesReleaseGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get economic data series that match search text
pub async fn fred_series_search_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    search_text: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
    search_type: Option<&str>,
    order_by: Option<&str>,
    sort_order: Option<&str>,
    filter_variable: Option<&str>,
    filter_value: Option<&str>,
    tag_names: Option<&str>,
    exclude_tag_names: Option<&str>,
) -> Result<(), Error<FredSeriesSearchGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_search_text = search_text;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_limit = limit;
    let p_offset = offset;
    let p_search_type = search_type;
    let p_order_by = order_by;
    let p_sort_order = sort_order;
    let p_filter_variable = filter_variable;
    let p_filter_value = filter_value;
    let p_tag_names = tag_names;
    let p_exclude_tag_names = exclude_tag_names;

    let uri_str = format!("{}/fred/series/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("search_text", &p_search_text.to_string())]);
    if let Some(ref param_value) = p_search_type {
        req_builder = req_builder.query(&[("search_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by {
        req_builder = req_builder.query(&[("order_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter_variable {
        req_builder = req_builder.query(&[("filter_variable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter_value {
        req_builder = req_builder.query(&[("filter_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tag_names {
        req_builder = req_builder.query(&[("tag_names", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude_tag_names {
        req_builder = req_builder.query(&[("exclude_tag_names", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSeriesSearchGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the related FRED tags for one or more FRED tags within a series search
pub async fn fred_series_search_related_tags_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    series_search_text: &str,
    tag_names: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredSeriesSearchRelatedTagsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_series_search_text = series_search_text;
    let p_tag_names = tag_names;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!(
        "{}/fred/series/search/related_tags",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("series_search_text", &p_series_search_text.to_string())]);
    req_builder = req_builder.query(&[("tag_names", &p_tag_names.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSeriesSearchRelatedTagsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the FRED tags for a series search
pub async fn fred_series_search_tags_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    series_search_text: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredSeriesSearchTagsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_series_search_text = series_search_text;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/series/search/tags", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("series_search_text", &p_series_search_text.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSeriesSearchTagsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the FRED tags for a series
pub async fn fred_series_tags_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    series_id: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredSeriesTagsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_series_id = series_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/series/tags", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("series_id", &p_series_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSeriesTagsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get economic data series sorted by when observations were updated
pub async fn fred_series_updates_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<(), Error<FredSeriesUpdatesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/fred/series/updates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSeriesUpdatesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the dates in history when a series' data values were revised or new data values were released
pub async fn fred_series_vintagedates_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    series_id: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredSeriesVintagedatesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_series_id = series_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/series/vintagedates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("series_id", &p_series_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSeriesVintagedatesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a source of economic data
pub async fn fred_source_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    source_id: i32,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredSourceGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_source_id = source_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/source", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("source_id", &p_source_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSourceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the releases for a source
pub async fn fred_source_releases_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    source_id: i32,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredSourceReleasesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_source_id = source_id;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/source/releases", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("source_id", &p_source_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSourceReleasesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all sources of economic data
pub async fn fred_sources_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredSourcesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/sources", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredSourcesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get FRED tags
pub async fn fred_tags_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_order: Option<&str>,
) -> Result<(), Error<FredTagsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_order = sort_order;

    let uri_str = format!("{}/fred/tags", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredTagsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the series matching tags
pub async fn fred_tags_series_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    tag_names: &str,
    file_type: Option<&str>,
    realtime_start: Option<String>,
    realtime_end: Option<String>,
) -> Result<(), Error<FredTagsSeriesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_tag_names = tag_names;
    let p_file_type = file_type;
    let p_realtime_start = realtime_start;
    let p_realtime_end = realtime_end;

    let uri_str = format!("{}/fred/tags/series", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_start {
        req_builder = req_builder.query(&[("realtime_start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_realtime_end {
        req_builder = req_builder.query(&[("realtime_end", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("tag_names", &p_tag_names.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FredTagsSeriesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Regional Data - Maps API
pub async fn geofred_regional_data_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    file_type: Option<&str>,
) -> Result<(), Error<GeofredRegionalDataGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_file_type = file_type;

    let uri_str = format!("{}/geofred/regional/data", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GeofredRegionalDataGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Series Data Info - Maps API
pub async fn geofred_series_data_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    series_id: &str,
    file_type: Option<&str>,
) -> Result<(), Error<GeofredSeriesDataGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_series_id = series_id;
    let p_file_type = file_type;

    let uri_str = format!("{}/geofred/series/data", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("series_id", &p_series_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GeofredSeriesDataGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Series Group Info - Maps API
pub async fn geofred_series_group_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    series_id: &str,
    file_type: Option<&str>,
) -> Result<(), Error<GeofredSeriesGroupGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_series_id = series_id;
    let p_file_type = file_type;

    let uri_str = format!("{}/geofred/series/group", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("series_id", &p_series_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GeofredSeriesGroupGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Shape Files - Maps API
pub async fn geofred_shape_files_get(
    configuration: &configuration::Configuration,
    api_key: &str,
    file_type: Option<&str>,
) -> Result<(), Error<GeofredShapeFilesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_key = api_key;
    let p_file_type = file_type;

    let uri_str = format!("{}/geofred/shape/files", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("api_key", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_file_type {
        req_builder = req_builder.query(&[("file_type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GeofredShapeFilesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
